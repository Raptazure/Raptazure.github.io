{"componentChunkName":"component---src-templates-post-tsx","path":"/posts/sml/","result":{"data":{"site":{"siteMetadata":{"title":"Raptazure","description":"魔法の森","author":{"name":"raptazure","twitter":"https://twitter.com/raptazure","github":"https://github.com/raptazure"}}},"mdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Standard ML\",\n  \"date\": \"2020-09-16T00:00:00.000Z\",\n  \"tags\": [\"PL\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h3\", null, \"ML Variable Bindings and Expressions\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"sml\"\n  }, mdx(\"pre\", _extends({\n    parentName: \"div\"\n  }, {\n    \"className\": \"language-sml\"\n  }), mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sml\"\n  }), \"val z = 3;\\n(* static environment: z : int *)\\n(* dynamic environment: z --> 3 *)\\n\\nval w = z + 1;\\n(* static environment: z : int, w : int *)\\n(* dynamic environment: z --> 3, w --> 4 *)\"))), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"The semantics\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Syntax is just how you write something\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Semantics is what something means\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Type-checking (before program runs)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Evaluation (as program runs)\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"For variable bindings:\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Type-check expression and extend static environment \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Evaluate expression and extend dynamic environment\")))), mdx(\"ol\", {\n    \"start\": 2\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Rules for expressions:\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Every kind of expression has:\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Syntax \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Type-checking rules. Produce a type or fails.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Evaluation rules (used only on things that type-check).\", mdx(\"br\", {\n    parentName: \"li\"\n  }), \"Produce a value (or exception or infinite-loop).\")))), mdx(\"ol\", {\n    \"start\": 3\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Reasons for shadowing:\")), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"sml\"\n  }, mdx(\"pre\", _extends({\n    parentName: \"div\"\n  }, {\n    \"className\": \"language-sml\"\n  }), mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sml\"\n  }), \"val a = 1\\nval b = a (* b is bound to 1 *)\\nval a = 2\"))), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Expressions in variable bindings are evaluated \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"eagerly\"), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Before the variable binding finishes\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Afterwards, the expression producing the value is irrelevant\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"There is no way to assign to a variable in ML\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Can only shadow in a later environment  \")))), mdx(\"h3\", null, \"ML Functions\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Functions informally\")), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"sml\"\n  }, mdx(\"pre\", _extends({\n    parentName: \"div\"\n  }, {\n    \"className\": \"language-sml\"\n  }), mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sml\"\n  }), \"fun pow (x : int, y : int) = \\n  if y = 0 \\n  then 1\\n  else x * pow (x, y - 1)\"))), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Cannot refer to later function bindings\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Simply ML`s rule\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Helper functions must come before their uses\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Need special construct for mutual recursion \")))), mdx(\"ol\", {\n    \"start\": 2\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Function bindings formally\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Syntax: \", mdx(\"code\", _extends({\n    parentName: \"li\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"fun x0 (x1 : t1, ..., xn : tn) = e\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Type-checking: \", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Add binding \", mdx(\"code\", _extends({\n    parentName: \"li\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"x0 : (t1 * ... * tn) -> t\"), \" if:\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Can type-check body \", mdx(\"code\", _extends({\n    parentName: \"li\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"e\"), \" to have type \", mdx(\"code\", _extends({\n    parentName: \"li\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"t\"), \" in the static environment containing:\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Enclosing static environment (earlier bindings)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"code\", _extends({\n    parentName: \"li\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"x1 : t1, ..., xn : tn\"), \" (arguments with their types)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"code\", _extends({\n    parentName: \"li\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"x0 : (t1 * ... * tn) -> t\"), \" (for recursion) \"))))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Evaluation: \", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"A function is a value \\u2014 we simply add x0 to the environment as a function that can be called later. \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"As expected for recursion, x0 is in the dynamic environment in the function body and for subsequent bindings.\")))), mdx(\"ol\", {\n    \"start\": 3\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Function calls formally\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Syntax: \", mdx(\"code\", _extends({\n    parentName: \"li\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"e0 (e1,...,en)\"), \" with the parentheses optional if there is exactly one argument.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Type-checking: require that \", mdx(\"code\", _extends({\n    parentName: \"li\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"e0\"), \" has a type that looks like \", mdx(\"code\", _extends({\n    parentName: \"li\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"t1 * ... * tn -> t\"), \" and for 1 \\u2264 i \\u2264 n, \", mdx(\"code\", _extends({\n    parentName: \"li\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"ei\"), \" has type \", mdx(\"code\", _extends({\n    parentName: \"li\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"ti\"), \". Then the whole call has type \", mdx(\"code\", _extends({\n    parentName: \"li\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"t\"), \".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Evaluation:\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Evaluate \", mdx(\"code\", _extends({\n    parentName: \"li\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"e0\"), \" to \", mdx(\"code\", _extends({\n    parentName: \"li\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"fun x0 (x1 : t1, ..., xn : tn) = e\"), \". Since call type-checked, result will be a function. Evaluate arguments to values \", mdx(\"code\", _extends({\n    parentName: \"li\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"v1, ..., vn\"), \" (Under current dynamic environment).\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Result is evaluation of \", mdx(\"code\", _extends({\n    parentName: \"li\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"e\"), \" in an environment extended to map \", mdx(\"code\", _extends({\n    parentName: \"li\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"x1\"), \" to \", mdx(\"code\", _extends({\n    parentName: \"li\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"v1, ..., xn\"), \" to \", mdx(\"code\", _extends({\n    parentName: \"li\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"vn\"), \" (An environment is actually the environment where the function was defined, and includes \", mdx(\"code\", _extends({\n    parentName: \"li\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"x0\"), \" for recursion).\")))), mdx(\"h3\", null, \"Pairs and Other Tuples\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Build\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Syntax: \", mdx(\"code\", _extends({\n    parentName: \"li\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"(e1, e2)\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Type-checking: if \", mdx(\"code\", _extends({\n    parentName: \"li\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"e1\"), \" has type \", mdx(\"code\", _extends({\n    parentName: \"li\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"ta\"), \" and \", mdx(\"code\", _extends({\n    parentName: \"li\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"e2\"), \" has type \", mdx(\"code\", _extends({\n    parentName: \"li\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"tb\"), \", then the pair expression has type \", mdx(\"code\", _extends({\n    parentName: \"li\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"ta * tb\"), \" - a new kind of type.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Evaluation: evaluate \", mdx(\"code\", _extends({\n    parentName: \"li\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"e1\"), \" to \", mdx(\"code\", _extends({\n    parentName: \"li\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"v1\"), \" and \", mdx(\"code\", _extends({\n    parentName: \"li\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"e2\"), \" to \", mdx(\"code\", _extends({\n    parentName: \"li\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"v2\"), \", result is \", mdx(\"code\", _extends({\n    parentName: \"li\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"(v1, v2)\"), \" - a pair of values is a value.\")), mdx(\"ol\", {\n    \"start\": 2\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Access\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Syntax: \", mdx(\"code\", _extends({\n    parentName: \"li\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"#1 e\"), \" and \", mdx(\"code\", _extends({\n    parentName: \"li\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"#2 e\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Type-checking: if \", mdx(\"code\", _extends({\n    parentName: \"li\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"e\"), \" has type \", mdx(\"code\", _extends({\n    parentName: \"li\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"ta * tb\"), \", then \", mdx(\"code\", _extends({\n    parentName: \"li\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"#1 e\"), \" has type \", mdx(\"code\", _extends({\n    parentName: \"li\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"ta\"), \" and \", mdx(\"code\", _extends({\n    parentName: \"li\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"#2 e\"), \" has type \", mdx(\"code\", _extends({\n    parentName: \"li\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"tb\"), \".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Evaluation: evaluate \", mdx(\"code\", _extends({\n    parentName: \"li\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"e\"), \" to a pair of values and return first or second piece.\")), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"sml\"\n  }, mdx(\"pre\", _extends({\n    parentName: \"div\"\n  }, {\n    \"className\": \"language-sml\"\n  }), mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sml\"\n  }), \"fun swap (pr : int * bool) = \\n  (#2 pr, #1 pr)\\n\\nfun sum_two_pairs (pr1 : int * int, pr2 : int * int) =\\n  (#1 pr1) + (#2 pr1) + (#1 pr2) + (#2 pr2)\\n\\nfun div_mod (x: int, y: int) =\\n  (x div y, x mod y)\\n\\nfun sort_pair (pr : int * int) =\\n  if (#1 pr) < (#2 pr)\\n  then pr\\n  else (#2 pr, #1 pr)\"))), mdx(\"ol\", {\n    \"start\": 3\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Tuple is a generalization of pairs. \")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Pairs and tuples can be nested (implied by the syntax and semantics)\")), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"sml\"\n  }, mdx(\"pre\", _extends({\n    parentName: \"div\"\n  }, {\n    \"className\": \"language-sml\"\n  }), mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sml\"\n  }), \"val x1 = (7, (true, 9))\\nval x2 = #1 (#2 x1)\"))), mdx(\"h3\", null, \"Lists\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Build: \", mdx(\"code\", _extends({\n    parentName: \"li\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"[v1, v2, ... ,vn]\"), \", \", mdx(\"code\", _extends({\n    parentName: \"li\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"::\"), \" pronounced \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"cons\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Access: \", mdx(\"code\", _extends({\n    parentName: \"li\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"null\"), \", \", mdx(\"code\", _extends({\n    parentName: \"li\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"hd\"), \", \", mdx(\"code\", _extends({\n    parentName: \"li\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"tl\"), \" \"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Functions over lists are usually recursive, only way to get to all the elements.\")), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"sml\"\n  }, mdx(\"pre\", _extends({\n    parentName: \"div\"\n  }, {\n    \"className\": \"language-sml\"\n  }), mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sml\"\n  }), \"fun sum_list (xs : int list) =\\n  if null xs\\n  then 0\\n  else hd(xs) + sum_list(tl xs)\\n  \\nfun countdown (x : int) =\\n  if x = 0\\n  then []\\n  else x :: countdown(x - 1)\\n\\nfun append (xs : int list, ys : int list) =\\n  if null xs\\n  then ys\\n  else (hd xs) :: append(tl xs, ys)\"))), mdx(\"h3\", null, \"Let Expressions\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"sml\"\n  }, mdx(\"pre\", _extends({\n    parentName: \"div\"\n  }, {\n    \"className\": \"language-sml\"\n  }), mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sml\"\n  }), \"fun countup_from (x : int) =\\n  let \\n    fun count (from : int) =\\n      if from = x\\n      then x :: []\\n      else from :: count (from + 1)\\n  in\\n    count (1)\\n  end\\n\\nfun max (xs : int list) =\\n  if null xs\\n  then 0\\n  else if null (tl xs)\\n  then hd xs\\n  else \\n    (* for style, could also use a let-binding for (hd xs) *)\\n    let val tl_ans = max (tl xs)\\n    in \\n      if hd xs > tl_ans\\n      then hd xs\\n      else tl_ans\\n    end\"))), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Syntax: \", mdx(\"code\", _extends({\n    parentName: \"li\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"let b1 b2 ... bn in e end\"), \". Each \", mdx(\"code\", _extends({\n    parentName: \"li\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"bi\"), \" is any binding and \", mdx(\"code\", _extends({\n    parentName: \"li\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"e\"), \" is any expression.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Type-checking: Type-check each \", mdx(\"code\", _extends({\n    parentName: \"li\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"bi\"), \" and \", mdx(\"code\", _extends({\n    parentName: \"li\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"e\"), \" in a static environment that includes the previous bindings. Type of whole let-expression is the type of \", mdx(\"code\", _extends({\n    parentName: \"li\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"e\"), \".\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Evaluation: Evaluate each \", mdx(\"code\", _extends({\n    parentName: \"li\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"bi\"), \" and \", mdx(\"code\", _extends({\n    parentName: \"li\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"e\"), \" in a dynamic environment that includes the previous bindings. Result of whole let-expression is result of evaluating \", mdx(\"code\", _extends({\n    parentName: \"li\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"e\"), \".\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Scope: where a binding is in the environment. Only in later bindings and body of the let-expression.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"The key to improve efficiency of recursion is not to do repeated work that might do repeated work. Saving recursive results in local bindings is essential.\")), mdx(\"h3\", null, \"Options\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"sml\"\n  }, mdx(\"pre\", _extends({\n    parentName: \"div\"\n  }, {\n    \"className\": \"language-sml\"\n  }), mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sml\"\n  }), \"fun max1 (xs : int list) =\\n  if null xs\\n  then NONE\\n  else \\n    let val tl_ans = max1 (tl xs)\\n    in if isSome tl_ans andalso valOf tl_ans > hd xs\\n      then tl_ans\\n      else SOME (hd xs)\\n    end\"))), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Building: \", mdx(\"code\", _extends({\n    parentName: \"li\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"NONE\"), \" has type \", mdx(\"code\", _extends({\n    parentName: \"li\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"'a option\"), \", \", mdx(\"code\", _extends({\n    parentName: \"li\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"SOME e\"), \" has type \", mdx(\"code\", _extends({\n    parentName: \"li\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"t option\"), \" if \", mdx(\"code\", _extends({\n    parentName: \"li\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"e\"), \" has type \", mdx(\"code\", _extends({\n    parentName: \"li\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"t\"), \".\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Accessing: \", mdx(\"code\", _extends({\n    parentName: \"li\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"isSome\"), \" has type \", mdx(\"code\", _extends({\n    parentName: \"li\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"'a option -> bool\"), \", \", mdx(\"code\", _extends({\n    parentName: \"li\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"valOf\"), \" has type \", mdx(\"code\", _extends({\n    parentName: \"li\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"'a option -> 'a\"), \"  (exception if given \", mdx(\"code\", _extends({\n    parentName: \"li\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"NONE\"), \").\")), mdx(\"h3\", null, \"Booleans and Comparison Operations\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Syntax: \", mdx(\"code\", _extends({\n    parentName: \"li\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"e1 andalso e2\"), \", \", mdx(\"code\", _extends({\n    parentName: \"li\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"e1 orelse e2\"), \", \", mdx(\"code\", _extends({\n    parentName: \"li\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"not e1\"), \".\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Short-circuiting evaluation means \", mdx(\"code\", _extends({\n    parentName: \"li\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"andalso\"), \" and \", mdx(\"code\", _extends({\n    parentName: \"li\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"orelse\"), \" are not functions, but \", mdx(\"code\", _extends({\n    parentName: \"li\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"not\"), \" is just a pre-defined function.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"code\", _extends({\n    parentName: \"li\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"=\"), \" \", mdx(\"code\", _extends({\n    parentName: \"li\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"<>\"), \" can be used with any equality type but not with \", mdx(\"code\", _extends({\n    parentName: \"li\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"real\"), \".\")), mdx(\"h3\", null, \"No Mutation: ML vs. Imperative Languages\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"In ML, we create aliases all the time without thinking about it because it is impossible to tell where there is aliasing.\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Example: \", mdx(\"code\", _extends({\n    parentName: \"li\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"tl\"), \" is constant time; does not copy rest of the list.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"So do not worry and focus on the algorithm.\"))), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"In language with mutable data (e.g. Java), programmers are obsessed with aliasing and object identity.\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"They have to be (!) so that subsequent assignments affect the right parts of the program.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Often crucial to make copies in just the right places.\"))), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Reference (alias) vs. copy does not matter if code is immutable.\")), mdx(\"h3\", null, \"Pieces of a Language\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Syntax\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Semantics (evaluation rules)\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Idioms (typical patterns for using language features to express the computation)\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Libraries\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Tools\")));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"ML Variable Bindings and Expressions The semantics Syntax is just how you write something Semantics is what something means Type-checking…","fields":{"lang":"zh-Hans"},"frontmatter":{"title":"Standard ML","date":"2020-09-16","tags":["PL"]}}},"pageContext":{"slug":"/posts/sml/"}},"staticQueryHashes":["2345487092"]}